import sys
import time
import fileinput


# ====== polyg parsing ========

def extract_edge(edge):
    tokens = edge.split(",")
    assert len(tokens) == 2, "ill-format edge: a,b"
    return [int(tokens[0]), int(tokens[1])]


def load_polyg(poly_f):
    with open(poly_f) as f:
        lines = f.readlines()

    n = 0
    edges = []
    constraints = []
    for line in lines:
        if line == "":
            continue

        elems = line.split(':')
        assert len(elems) == 2, "ill-format log"
        symbol = elems[0]
        content = elems[1]

        if symbol == "n":
            assert n==0, "multiple n in file"
            n = int(content)
        elif symbol == "e":
            e = extract_edge(content)
            edges.append(e)
        elif symbol == "c":
            str_groups = content.split("|")
            assert len(str_groups) == 2, "ill-format constraints, not two groups"
            con = [[int(g) for g in group.split(',')] for group in str_groups]
            constraints.append(con)
        else:
            print("Line = %s" % line)
            assert False, "should never be here"

    return n, edges, constraints

# ========= CNF ============

class CNFBuilder:

    def __init__(self, output_file):
        self.vars = {}
        self.var_num = 1
        self.clauses = []
        # for dump
        self.output_file = output_file
        self.fd = open(output_file, 'w')
        self.first_dump = True
        self.clause_num = 0

    def Bool(self, name):
        if name in self.vars:
            return self.vars[name]
        else:
            self.vars[name] = self.var_num
            self.var_num += 1
            return self.vars[name]

    def Implies(self, var1, var2):
        return self.Or(self.Not(var1), var2)

    def Or(self, *args):
        return [*args]

    def append_Xor(self, var1, var2):
        Bool, Not, Or, Implies = self.aliases()
        # xor is associative
        self.clauses.append(Or(Not(var1), Not(var2)))
        self.clauses.append(Or(var1, var2))

    def append(self, or_clause):
        if isinstance(or_clause, list):
            self.clauses.append(or_clause)
        else:
            self.clauses.append([or_clause])

    def Not(self, var):
        return -var

    def __str__(self):
        return self.serialize()

    def serialize(self):
        lines = ['c',
                 'c generated by mike',
                 'c']
        lines.append('p cnf ' + str(len(self.vars)) + ' ' + str(len(self.clauses)))
        for clause in self.clauses:
            lines.append(' '.join([str(c) for c in clause]) + ' 0')

        return '\n'.join(lines)

    def full_dump(self):
        self.fd.write(str(self))
        self.fd.close()

    def partial_dump(self):
        lines = []
        if self.first_dump:
            lines = ['c',
                     'c generated by mike',
                     'c']
            lines.append('p cnf ' + str(len(self.vars)) + ' [placeholder]')
            self.first_dump = False

        for clause in self.clauses:
            lines.append(' '.join([str(c) for c in clause]) + ' 0')
        output = '\n'.join(lines)
        output = output + "\n"

        # dump current output to file
        self.fd.write(output)

        # clear
        self.clause_num = self.clause_num + len(self.clauses)
        self.clauses = []

    def complete_dump(self):
        # close the file
        self.fd.close()
        # update the number of clauses
        for line in fileinput.input(self.output_file, inplace=True):
            if "[placeholder]" in line:
                print('p cnf ' + str(len(self.vars)) + ' ' + str(self.clause_num))
            else:
                print(line, end="")



    def aliases(self):
        return (self.Bool, self.Not, self.Or, self.Implies)

def AndImplies(b, var1, var2, var3):
    Bool, Not, Or, Implies = b.aliases()
    # https://www.wolframalpha.com/input/?i=+CNF+%28%28a+and+b%29+implies+c%29
    # (A and B) implies C
    return Or(Not(var1), Not(var2), var3)


vars = []
vars_aux = []

def generate_vars(n, b):
    global vars, vars_aux
    Bool, Not, Or, Implies = b.aliases()
    print("generating variables...")
    vars = [[Bool(label([i, j])) for i in range(n)] for j in range(n)]
    vars_aux = [[Bool(label_aux([i, j])) for i in range(n)] for j in range(n)]
    print("done generating variables.")

def var(edge):
    return vars[edge[0]][edge[1]]

def aux(edge):
    return vars_aux[edge[0]][edge[1]]

def label(edge):
    # be careful of slow str ops;
    # could just label e1, e2 ... (hard to lookup with constraints tho)
    return ','.join([str(e) for e in edge])

def label_aux(edge):
    return 'a' + label(edge)

def polygraph_sat(n, edges, constraints, b):
    for edge in edges:
        b.append(var(edge))

    for constraint in constraints:
        b.append_Xor(var(constraint[0]),
                     var(constraint[1]))


# ======== encodings =============

def encode_polyg_tc1(n, edges, constraints, b):
    Bool, Not, Or, Implies = b.aliases()

    for begin in range(n):
        b.append(Not(aux([begin, begin])))                             # 1) irreflexive
        for end in range(n):
            b.append(Implies(var([begin, end]), aux([begin, end])))    # 3) closure of edges
            for mid in range(n):
                clause = AndImplies(b, aux([begin, mid]), aux([mid, end]), aux([begin, end]))
                b.append(clause)                                       # 2) transitive
        print('\r{:.2f}%'.format(begin / n * 100), end='')
    print('\n')

def encode_polyg_be19(n, edges, constraints, b):
    global is_partial_dump
    Bool, Not, Or, Implies = b.aliases()

    for begin in range(n):
        for end in range(n):
            b.append(Implies(var([begin, end]), aux([begin, end]))) # (1) edge implies CO

            if begin != end:
                b.append_Xor(aux([begin, end]), aux([end,begin])) # (2) CO is total order

                # CO is transitive; copied logic from sat.rs in dbcop
                for mid in range(n):
                    clause = AndImplies(b, aux([begin, mid]), aux([mid, end]), aux([begin, end]))
                    b.append(clause)                                       # 2) transitive
        print('\r{:.2f}%'.format(begin / n * 100), end='')
        if is_partial_dump:
            b.partial_dump()
    print('\n')






# ========== main logic ===========
is_partial_dump = False

def main(encoding, poly_f, output_file):
    n, edges, constraints = load_polyg(poly_f)

    t1 = time.time()

    b = CNFBuilder(output_file)
    generate_vars(n, b)

    polygraph_sat(n, edges, constraints, b)

    print('encoding...')
    if encoding == 'tc1':
        encode_polyg_tc1(n, edges, constraints, b)
    elif encoding == 'be19':
        encode_polyg_be19(n, edges, constraints, b)
    else:
        print("ERROR: unknown encoding [%s]" % encoding)
        exit(1)

    t2 = time.time()
    print("clause construction and dump: %.fms" % ((t2-t1)*1000))

    if is_partial_dump:
        b.partial_dump()
        # rewrite the number of clauses
        b.complete_dump()
    else:
        b.full_dump()

    print('done.')



def usage_exit():
    print("Usage: veri_polyg.py [tc1|be19] [full|partial] <polyg_file> <cnf_file>")
    exit(1)

if __name__ == "__main__":
    if len(sys.argv) != 5:
        usage_exit()
    is_partial_dump = ("partial" in sys.argv[2])
    output_file = sys.argv[4]
    main(sys.argv[1], sys.argv[3], output_file)
